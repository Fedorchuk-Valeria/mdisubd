-- CREATE TABLE MyTable(
--     id NUMBER GENERATED BY DEFAULT AS IDENTITY,
--     name VARCHAR2(20),
--     value NUMBER
-- );

-- task1

-- CREATE TABLE Attributes(
--     name VARCHAR2(20)
-- );
-- INSERT INTO Attributes VALUES('join');

-- CREATE TABLE ConditionAttributes(
--     name VARCHAR2(20)
-- );
-- INSERT INTO ConditionAttributes VALUES('second_op');

-- CREATE TABLE JsonString(
--     id NUMBER,
--     value VARCHAR2(600)
-- );

-- DROP TABLE JsonString;

-- INSERT INTO JsonString VALUES(1, ' ');

DROP FUNCTION SelectParse;

CREATE FUNCTION SelectParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM Attributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'where' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ' WHERE ';
            result := result || ConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DROP FUNCTION InnerSelectParse;

CREATE FUNCTION InnerSelectParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(100) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(500);
CURSOR attr IS SELECT * FROM Attributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('innerselect');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DROP FUNCTION ConditionParse;

CREATE FUNCTION ConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(500) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(500);
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',', 1);
        IF j = 0 THEN
            j := INSTR(json_str, '}', 1);
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
            result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
            result := result || InnerConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('condition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

DROP FUNCTION TwoInnerConditionParse;

CREATE FUNCTION InnerConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(200) := '';
i NUMBER;
j NUMBER;
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
json_str VARCHAR2(500);
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
            result := result || TwoInnerConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
            result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('innercondition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

CREATE FUNCTION TwoInnerConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(200) := '';
i NUMBER;
j NUMBER;
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
json_str VARCHAR2(500);
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        -- IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
        --     result := result || TwoInnerConditionParse(SUBSTR(json_str, i));
        --     CONTINUE;
        -- END IF;
        -- IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
        --     result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
        --     CONTINUE;
        -- END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('innerinnercondition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

DROP FUNCTION Parse;

CREATE FUNCTION Parse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
BEGIN
   result := SelectParse(json_string);
   RETURN result;
END;

BEGIN
    DBMS_OUTPUT.PUT_LINE(Parse('{ "type": SELECT, "cols": id, "tables": FROM MyTable1, "where": 
    { "first_op": 
    { "where": { "first_op": id, "operator": IN, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable2, "where": no, "join": no } } }, 
    "operator": AND, "second_op": 
    { "where": { "first_op":
    { "where": { "first_op": name, "operator": LIKE, "second_op": "HGCX"}}, "operator": AND,  "second_op": 
    { "where": { "first_op": age, "operator": BETWEEN, "second_op": 12 AND 20 }
    }}, 
    "join": no }'));
END;

BEGIN
    DBMS_OUTPUT.PUT_LINE(Parse('{ "type": SELECT, "cols": id/name, "tables": FROM MyTable, "where": 
    { "first_op": no, "operator": EXISTS, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable2, "where": no, "join": no } }, "join": no }'));
END;

DECLARE
   TYPE EmpCurTyp IS REF CURSOR;
   emp_cv   EmpCurTyp;
   CURSOR c1 IS
      SELECT name FROM MyTable;
   emp_rec  c1%ROWTYPE;
   sql_stmt VARCHAR2(200);
BEGIN
   sql_stmt := Parse('{ "type": SELECT, "cols": name, "tables": FROM MyTable, "where": 
    { "first_op": id, "operator": =, "second_op": 1 }, "join": no }');
   OPEN emp_cv FOR sql_stmt;
   LOOP
      FETCH emp_cv INTO emp_rec;
      EXIT WHEN emp_cv%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(emp_rec.name);
   END LOOP;
   CLOSE emp_cv;
END;

DECLARE
   TYPE CurTyp IS REF CURSOR;
   table_cv CurTyp;
   table_rec MyTable%ROWTYPE;
   sql_stmt VARCHAR2(200);
BEGIN
   sql_stmt := Parse('{"type": SELECT, "cols": *, "tables": FROM MyTable, "where": no, "join": no }');
   OPEN table_cv FOR sql_stmt;
   LOOP
      FETCH table_cv INTO table_rec;
      EXIT WHEN table_cv%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('id '||table_rec.id|| ' name ' ||table_rec.name|| ' value ' ||table_rec.value|| ';');
   END LOOP;
   CLOSE table_cv;
END;
