-- CREATE TABLE MyTable(
--     id NUMBER GENERATED BY DEFAULT AS IDENTITY,
--     name VARCHAR2(20),
--     value NUMBER
-- );

-- task1-2

-- CREATE TABLE Attributes(
--     name VARCHAR2(20)
-- );
-- INSERT INTO Attributes VALUES('join');

-- CREATE TABLE ConditionAttributes(
--     name VARCHAR2(20)
-- );
-- INSERT INTO ConditionAttributes VALUES('second_op');

-- CREATE TABLE JsonString(
--     id NUMBER,
--     value VARCHAR2(600)
-- );

-- DROP TABLE JsonString;

-- INSERT INTO JsonString VALUES(1, ' ');

---SELECT

DROP FUNCTION Parse;

CREATE FUNCTION Parse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
BEGIN
   result := SelectParse(json_string);
   RETURN result;
END;

DROP FUNCTION SelectParse;

CREATE FUNCTION SelectParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM Attributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'where' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ' WHERE ';
            result := result || ConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DROP FUNCTION InnerSelectParse;

CREATE FUNCTION InnerSelectParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(100) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(500);
CURSOR attr IS SELECT * FROM Attributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'where' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ' WHERE ';
            result := result || TwoInnerConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('innerselect');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DROP FUNCTION ConditionParse;

CREATE FUNCTION ConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(500) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(500);
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',', 1);
        IF j = 0 THEN
            j := INSTR(json_str, '}', 1);
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
            result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
            result := result || InnerConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('condition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

DROP FUNCTION TwoInnerConditionParse;

CREATE FUNCTION InnerConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(200) := '';
i NUMBER;
j NUMBER;
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
json_str VARCHAR2(500);
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
            result := result || TwoInnerConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
            result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('innercondition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

CREATE FUNCTION TwoInnerConditionParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(200) := '';
i NUMBER;
j NUMBER;
CURSOR attr IS SELECT * FROM Attributes;
CURSOR con_attr IS SELECT * FROM ConditionAttributes;
json_str VARCHAR2(500);
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        -- IF INSTR(SUBSTR(json_str, i, j - i), 'where') <> 0 THEN
        --     result := result || TwoInnerConditionParse(SUBSTR(json_str, i));
        --     CONTINUE;
        -- END IF;
        -- IF INSTR(SUBSTR(json_str, i, j - i), 'SELECT') < j - i - 4 AND INSTR(SUBSTR(json_str, i, j - i), 'SELECT') <> 0 THEN
        --     result := result || ' (' || InnerSelectParse(SUBSTR(json_str, i)) || ')';
        --     CONTINUE;
        -- END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('innerinnercondition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

BEGIN
    DBMS_OUTPUT.PUT_LINE(Parse('{ "type": SELECT, "cols": id, "tables": FROM MyTable1, "where": 
    { "first_op": 
    { "where": { "first_op": id, "operator": IN, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable2, "where": no, "join": no } } }, 
    "operator": AND, "second_op": 
    { "where": { "first_op":
    { "where": { "first_op": name, "operator": LIKE, "second_op": "HGCX"}}, "operator": AND,  "second_op": 
    { "where": { "first_op": age, "operator": BETWEEN, "second_op": 12 AND 20 }
    }}, 
    "join": no }'));
END;

BEGIN
    DBMS_OUTPUT.PUT_LINE(Parse('{ "type": SELECT, "cols": id/name, "tables": FROM MyTable, "where": 
    { "first_op": no, "operator": EXISTS, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable2, "where": no, "join": no } }, "join": no }'));
END;

DECLARE
   TYPE EmpCurTyp IS REF CURSOR;
   emp_cv   EmpCurTyp;
   CURSOR c1 IS
      SELECT name FROM MyTable;
   emp_rec  c1%ROWTYPE;
   sql_stmt VARCHAR2(200);
BEGIN
   sql_stmt := Parse('{ "type": SELECT, "cols": name, "tables": FROM MyTable, "where": 
    { "first_op": id, "operator": =, "second_op": 1 }, "join": no }');
   OPEN emp_cv FOR sql_stmt;
   LOOP
      FETCH emp_cv INTO emp_rec;
      EXIT WHEN emp_cv%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(emp_rec.name);
   END LOOP;
   CLOSE emp_cv;
END;

DECLARE
   TYPE CurTyp IS REF CURSOR;
   table_cv CurTyp;
   table_rec MyTable%ROWTYPE;
   sql_stmt VARCHAR2(200);
BEGIN
   sql_stmt := SelectParse('{"type": SELECT, "cols": *, "tables": FROM MyTable, "where": no, "join": no }');
   OPEN table_cv FOR sql_stmt;
   LOOP
      FETCH table_cv INTO table_rec;
      EXIT WHEN table_cv%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('id '||table_rec.id|| ' value ' ||table_rec.value|| ';');
   END LOOP;
   CLOSE table_cv;
END;

-- task3

-- CREATE TABLE InsertAttributes(
--     name VARCHAR2(20)
-- );

-- DROP TABLE InsertAttributes;
-- INSERT INTO InsertAttributes VALUES('values');

-- CREATE TABLE UpdateAttributes(
--     name VARCHAR2(20)
-- );

-- INSERT INTO UpdateAttributes VALUES('where');

CREATE TABLE DeleteAttributes(
    name VARCHAR2(20)
);

INSERT INTO DeleteAttributes VALUES('where');

DROP FUNCTION Parse;

CREATE FUNCTION Parse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
BEGIN
   result := CreateParse(json_string);
   RETURN result;
END;

--INSERT

DROP FUNCTION InsertParse;

CREATE FUNCTION InsertParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM InsertAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'values' THEN
                result := result || ' VALUES ';
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            IF a.name = 'cols' OR a.name = 'values' THEN
                result := result || '(' || SUBSTR(json_str, i, j - i) || ')';
            ELSE
                result := result || SUBSTR(json_str, i, j - i); 
            END IF;
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DECLARE 
result VARCHAR2(600);
BEGIN
    result := InsertParse('{ "type": INSERT, "tables": INTO MyTable, "cols": id/value, "values": 9/25 }');
    DBMS_OUTPUT.PUT_LINE(result);
    EXECUTE IMMEDIATE result;
END;

--UPDATE

DROP FUNCTION UpdateParse;

CREATE FUNCTION UpdateParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM UpdateAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        IF a.name = 'cols' THEN
            result := result || ' SET ';
        END IF;
        IF a.name = 'values' THEN
            result := result || ' = ';
        END IF;
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'where' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ' WHERE ';
            result := result || ConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        result := REPLACE(result, '/', ', ');
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;


DECLARE
result VARCHAR2(600);
BEGIN
    result := UpdateParse('{ "type": UPDATE, "tables": MyTable, "cols": value, "values": 5, "where": 
    { "first_op": id, "operator": =, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable, "where": 
    { "first_op": value, "operator": =, "second_op": 25 }, "join": no } } }');
    DBMS_OUTPUT.PUT_LINE(result);
    EXECUTE IMMEDIATE result;
END;

--DELETE

DROP FUNCTION DeleteParse;

CREATE FUNCTION DeleteParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM DeleteAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'where' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ' WHERE ';
            result := result || ConditionParse(SUBSTR(json_str, i));
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DECLARE
result VARCHAR2(600);
BEGIN
    result := DeleteParse('{ "type": DELETE, "tables": FROM MyTable, "where": 
    { "first_op": id, "operator": =, "second_op": 
    { "type": SELECT, "cols": id, "tables": FROM MyTable, "where": 
    { "first_op": value, "operator": =, "second_op": 5 }, "join": no } } }');
    DBMS_OUTPUT.PUT_LINE(result);
    EXECUTE IMMEDIATE result;
END;

--task4

CREATE TABLE DropAttributes(
    name VARCHAR2(20)
);

INSERT INTO DropAttributes VALUES('tables');

--DROP

DROP FUNCTION DropParse;

CREATE FUNCTION DropParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
json_str VARCHAR2(600) := '';
CURSOR attr IS SELECT * FROM DeleteAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('select');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;   
END;

DECLARE
    result VARCHAR2(500);
BEGIN
    result := DropParse('{ "type": DROP TABLE, "tables": MyTable }');
    DBMS_OUTPUT.PUT_LINE(result);
    EXECUTE IMMEDIATE result;
END;

CREATE TABLE CreateAttributes(
    name VARCHAR2(20)
);

INSERT INTO CreateAttributes VALUES('constr');

CREATE TABLE ConstrAttributes(
    name VARCHAR2(20)
);

INSERT INTO ConstrAttributes VALUES('cols');

--CREATE + TRIGGER (TASK5)
DROP FUNCTION GenerateTrigger;

CREATE TABLE TriggerParam(
    id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    t VARCHAR2(50),
    col VARCHAR2(50)
)

INSERT INTO TriggerParam VALUES (1, ' ', ' ');

CREATE FUNCTION GenerateTrigger(t IN VARCHAR2, c IN VARCHAR2) RETURN VARCHAR2
IS
result VARCHAR2(900) := '';
BEGIN
    result := 'CREATE TRIGGER AutoincrementId BEFORE INSERT ON ' ||t|| ' FOR EACH ROW DECLARE PRAGMA AUTONOMOUS_TRANSACTION; newId NUMBER := 0; BEGIN SELECT ' ||c|| ' INTO newId FROM ' ||t|| ' ORDER BY id DESC FETCH FIRST 1 ROWS ONLY;
:NEW.id := newId + 1;
EXCEPTION WHEN NO_DATA_FOUND THEN
:NEW.id := 1;
 END;';
    EXECUTE IMMEDIATE result;
    RETURN result;
END;

DROP FUNCTION ConstraintParse;

CREATE FUNCTION ConstraintParse(json_string IN VARCHAR2, tab IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(200) := '';
i NUMBER;
j NUMBER;
CURSOR con_attr IS SELECT * FROM ConstrAttributes;
json_str VARCHAR2(500);
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR c_a IN con_attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, c_a.name);
        i := i + LENGTH(c_a.name) + 2;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF c_a.name = 'cols' THEN
            UPDATE TriggerParam SET t = tab, col = SUBSTR(json_str, i, j - i) WHERE id = 1;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        result := REPLACE(result, '}', '');
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
        -- DBMS_OUTPUT.PUT_LINE('innerinnercondition');
        -- DBMS_OUTPUT.PUT_LINE(result);
        -- DBMS_OUTPUT.PUT_LINE(SUBSTR(json_str, j + 1));
    END LOOP;
    RETURN result;
END;

DROP FUNCTION CreateParse;

CREATE FUNCTION CreateParse(json_string IN VARCHAR2) RETURN VARCHAR2 
IS
result VARCHAR2(400) := '';
i NUMBER;
j NUMBER;
b1 NUMBER := 1;
b2 NUMBER := 1;
json_str VARCHAR2(600) := '';
c VARCHAR2(50) := '';
t VARCHAR2(50) := '';
CURSOR attr IS SELECT * FROM CreateAttributes;
BEGIN
    UPDATE JsonString SET value = json_string WHERE id = 1;
    FOR a IN attr
    LOOP
        SELECT value INTO json_str FROM JsonString WHERE id = 1;
        i := INSTR(json_str, a.name);
        i := i + LENGTH(a.name) + 2;
        IF a.name = 'cols' THEN
        result := result || '( ';
            i := INSTR(json_str, '[', 1, b1);
            j := INSTR(json_str, ']', 1, b2);
            WHILE i <> 0
            LOOP
                IF b1 <> 1 THEN
                    result := result || ', ' ;
                END IF;
                c := SUBSTR(json_str, i, j - i);
                j := INSTR(c, ',');
                result := result || SUBSTR(c, 2, j - 2) || SUBSTR(c, j + 1);
                b1 := b1 + 1;
                b2 := b2 + 1;
                i := INSTR(json_str, '[', 1, b1);
                j := INSTR(json_str, ']', 1, b2);
            END LOOP;
            UPDATE JsonString SET value = SUBSTR(json_str, INSTR(json_str, ']', 1, b2 - 1) + 2) WHERE id = 1;
            CONTINUE;
        END IF;
        j := INSTR(json_str, ',');
        IF j = 0 THEN
            j := INSTR(json_str, '}');
        END IF;
        IF a.name = 'tables' THEN
            t := SUBSTR(json_str, i, j - i);
        END IF;
        IF a.name = 'constr' AND (INSTR(SUBSTR(json_str, i, j - i), 'no') > 3 OR INSTR(SUBSTR(json_str, i, j - i), 'no') = 0) THEN
            result := result || ', CONSTRAINT ';
            result := result || ConstraintParse(SUBSTR(json_str, i), t);
            result := result || ') ';
            CONTINUE;
        END IF;
        IF INSTR(SUBSTR(json_str, i, j - i), 'no') = 0 THEN
            result := result || SUBSTR(json_str, i, j - i);
        END IF;
        UPDATE JsonString SET value = SUBSTR(json_str, j + 1) WHERE id = 1;
    END LOOP;
    RETURN result;   
END;

DECLARE
    result VARCHAR2(600);
    tab VARCHAR2(50);
    c VARCHAR2(50);
BEGIN
    result := CreateParse('{ "type": CREATE TABLE, "tables": MyTable, "cols": [id, NUMBER], [value, NUMBER], "constr": 
    {"name": mytable_pk, "type": PRIMARY KEY, "cols": (id)}}');
    DBMS_OUTPUT.PUT_LINE(result);
    EXECUTE IMMEDIATE result;
    SELECT t INTO tab FROM TriggerParam WHERE id = 1;
    SELECT col INTO c FROM TriggerParam WHERE id = 1;
    DBMS_OUTPUT.PUT_LINE(GenerateTrigger(tab, c));
END;