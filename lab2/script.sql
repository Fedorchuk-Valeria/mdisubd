-- task1

-- DROP TABLE Students;
-- DROP TABLE Groups;

-- CREATE TABLE Students(
--     id NUMBER,
--     name VARCHAR2(15),
--     group_id NUMBER
-- );

-- CREATE TABLE Groups(
--     id NUMBER GENERATED BY DEFAULT AS IDENTITY,
--     name VARCHAR2(15),
--     c_val NUMBER
-- );


-- task2

-- DROP TRIGGER Unique_student_id;

-- CREATE TRIGGER Unique_student_id 
-- BEFORE INSERT OR UPDATE OF id
-- ON Students
-- FOR EACH ROW
-- DECLARE
--     not_unique EXCEPTION;
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     PRAGMA EXCEPTION_INIT(not_unique, -0125673);
--     c NUMBER := 0;
-- BEGIN
--     SELECT COUNT(*) INTO c FROM Students WHERE id = :NEW.id; 
--     IF c > 0 THEN
--         RAISE not_unique;
--     END IF;
-- END;

-- DROP TRIGGER Unique_group_id;

-- CREATE TRIGGER Unique_group_id 
-- BEFORE INSERT OR UPDATE OF id
-- ON Groups
-- FOR EACH ROW
-- DECLARE
--     not_unique EXCEPTION;
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     PRAGMA EXCEPTION_INIT(not_unique, -0123428);
--     c NUMBER := 0;
-- BEGIN
--     SELECT COUNT(*) INTO c FROM Groups WHERE id = :NEW.id; 
--     IF c > 0 THEN
--         RAISE not_unique;
--     END IF;
-- END;

-- DROP TRIGGER Unique_group_name;

-- CREATE TRIGGER Unique_group_name 
-- BEFORE INSERT OR UPDATE OF name
-- ON Groups
-- FOR EACH ROW
-- DECLARE
--     not_unique EXCEPTION;
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     PRAGMA EXCEPTION_INIT(not_unique, -0127389);
--     c NUMBER := 0;
-- BEGIN
--     SELECT COUNT(*) INTO c FROM Groups WHERE name = :NEW.name; 
--     IF c > 0 THEN
--         RAISE not_unique;
--     END IF;
-- END;

-- DROP TRIGGER AutoincrementStudentId;

-- CREATE TRIGGER AutoincrementStudentId
-- BEFORE INSERT 
-- ON Students
-- FOR EACH ROW
-- FOLLOWS Unique_student_id
-- DECLARE
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     newId NUMBER := 0;
-- BEGIN
--     SELECT id INTO newId FROM Students ORDER BY id DESC FETCH FIRST 1 ROWS ONLY;
--     :NEW.id := newId + 1;
-- EXCEPTION WHEN NO_DATA_FOUND THEN
--     :NEW.id := 1;
-- END;

-- DROP TRIGGER AutoincrementGroupId;

-- CREATE TRIGGER AutoincrementGroupId
-- BEFORE INSERT 
-- ON Groups
-- FOR EACH ROW
-- FOLLOWS Unique_group_id
-- DECLARE
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     newId NUMBER := 0;
-- BEGIN
--     SELECT id INTO newId FROM Groups ORDER BY id DESC FETCH FIRST 1 ROWS ONLY;
--     :NEW.id := newId + 1;
-- EXCEPTION WHEN NO_DATA_FOUND THEN
--     :NEW.id := 1;
-- END;

-- task 3

-- CREATE TRIGGER CascadeDelete
-- BEFORE DELETE
-- ON GROUPS
-- FOR EACH ROW
-- BEGIN
--     DELETE FROM Students WHERE group_id = :OLD.id;
-- END;

-- DROP TRIGGER ForeignKey;

-- CREATE TRIGGER ForeignKey
-- BEFORE INSERT OR UPDATE OF group_id
-- ON Students
-- FOR EACH ROW
-- FOLLOWS Unique_student_id
-- DECLARE
--     not_exist EXCEPTION;
--     PRAGMA AUTONOMOUS_TRANSACTION;
--     PRAGMA EXCEPTION_INIT(not_exist, -0106138);
--     c NUMBER := 0;
-- BEGIN
--     SELECT COUNT(*) INTO c FROM Groups WHERE id = :NEW.group_id; 
--     IF c != 1 THEN
--         RAISE not_exist;
--     END IF;
-- END;

-- task 4

-- DROP TABLE Logs;

-- CREATE TABLE Logs(
--     id NUMBER GENERATED BY DEFAULT AS IDENTITY,
--     type VARCHAR2(10),
--     new_id NUMBER NULL,
--     old_id NUMBER NULL,
--     new_name VARCHAR(10) NULL,
--     old_name VARCHAR(10) NULL,
--     new_group NUMBER NULL,
--     old_group NUMBER NULL,
--     time TIMESTAMP
-- );

-- DROP TRIGGER Logs;

-- CREATE TRIGGER LOGS
-- AFTER DELETE OR UPDATE OR INSERT
-- ON Students
-- FOR EACH ROW
-- BEGIN
--     IF DELETING THEN
--         INSERT INTO Logs(type, new_id, old_id, new_name, old_name, new_group, old_group, time) 
--                         VALUES ('DELETE', null, :OLD.id, null, :OLD.name, null, :OLD.group_id, TO_TIMESTAMP(TO_CHAR(SYSDATE, 'yyyy-mm-dd hh:mi:ss'), 'yyyy-mm-dd hh:mi:ss'));
--     ELSIF UPDATING THEN
--         INSERT INTO Logs(type, new_id, old_id, new_name, old_name, new_group, old_group, time) 
--                         VALUES ('UPDATE', :NEW.id, :OLD.id, :NEW.name, :OLD.name, :NEW.group_id, :OLD.group_id, TO_TIMESTAMP(TO_CHAR(SYSDATE, 'yyyy-mm-dd hh:mi:ss'), 'yyyy-mm-dd hh:mi:ss'));
--     ELSIF INSERTING THEN
--         INSERT INTO Logs(type, new_id, old_id, new_name, old_name, new_group, old_group, time) 
--                         VALUES ('INSERT', :NEW.id, null, :NEW.name, null, :NEW.group_id, null, TO_TIMESTAMP(TO_CHAR(SYSDATE, 'yyyy-mm-dd hh:mi:ss'), 'yyyy-mm-dd hh:mi:ss'));
--     END IF;
-- END;

-- task 5

-- DROP PROCEDURE RestoreDataByTime;

-- CREATE PROCEDURE RestoreDataByTime(t IN TIMESTAMP)
-- IS
-- CURSOR log IS SELECT * FROM Logs WHERE time >= t ORDER BY time DESC;
-- BEGIN
--     FOR l IN log
--     LOOP
--         IF l.type = 'DELETE' THEN
--             INSERT INTO Students VALUES (l.old_id, l.old_name, l.old_group);
--         ELSIF l.type = 'UPDATE' THEN
--             UPDATE Students SET name = l.old_name, group_id = l.old_group WHERE id = l.new_id; 
--         ELSIF l.type = 'INSERT' THEN
--             DELETE FROM Students WHERE id = l.new_id;
--         END IF;
--     END LOOP;
--     DELETE FROM Logs WHERE time >= t;
-- END RestoreDataByTime;

-- DROP PROCEDURE RestoreDataByInterval;

-- CREATE PROCEDURE RestoreDataByInterval(st IN TIMESTAMP, fin IN TIMESTAMP)
-- IS
-- CURSOR log IS 
-- SELECT * FROM Logs WHERE time>=st AND time<=fin ORDER BY time DESC;
-- BEGIN
--     FOR l IN log
--     LOOP
--         IF l.type = 'DELETE' THEN
--             INSERT INTO Students VALUES (l.old_id, l.old_name, l.old_group);
--         ELSIF l.type = 'UPDATE' THEN
--             UPDATE Students SET name = l.old_name, group_id = l.old_group WHERE id = l.new_id; 
--         ELSIF l.type = 'INSERT' THEN
--             DELETE FROM Students WHERE id = l.new_id;
--         END IF;
--     END LOOP;
--     DELETE FROM Logs WHERE time>=st AND time<=fin;
-- END RestoreDataByInterval;

-- task 6

-- CREATE TRIGGER UpdateCountOfStudents
-- AFTER INSERT OR UPDATE OF group_id OR DELETE
-- ON Students
-- FOR EACH ROW
-- DECLARE 
--     c NUMBER;
-- BEGIN
--     IF INSERTING THEN
--         SELECT c_val INTO c FROM Groups WHERE id = :NEW.group_id;
--         c := c + 1;
--         UPDATE Groups SET c_val = c WHERE id = :NEW.group_id;
--     ELSIF DELETING THEN
--         SELECT c_val INTO c FROM Groups WHERE id = :OLD.group_id;
--         c := c - 1;
--         UPDATE Groups SET c_val = c WHERE id = :OLD.group_id;
--     ELSIF UPDATING THEN
--         SELECT c_val INTO c FROM Groups WHERE id = :NEW.group_id;
--         c := c + 1;
--         UPDATE Groups SET c_val = c WHERE id = :NEW.group_id;
--         SELECT c_val INTO c FROM Groups WHERE id = :OLD.group_id;
--         c := c - 1;
--         UPDATE Groups SET c_val = c WHERE id = :OLD.group_id;
--     END IF;
-- END;


-- INSERT INTO Students VALUES (10, 'pika', 2);
BEGIN 
    RestoreDataByInterval(TO_TIMESTAMP('27-FEB-23 01.50.05.000000000 AM'), TO_TIMESTAMP('27-FEB-23 01.53.05.000000000 AM'));
END;
/


-- UPDATE Students SET name = 'mama' WHERE id = 9;
SELECT * FROM Students;